# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

backsolveBatchBackend <- function(C, A, B, Cstartend, Astartend, Bstartend, numbatchB, diagIsOne, Nglobal, Nlocal, NlocalCache = 1000L, verbose = 0L) {
    .Call('_gpuLik_backsolveBatchBackend', PACKAGE = 'gpuLik', C, A, B, Cstartend, Astartend, Bstartend, numbatchB, diagIsOne, Nglobal, Nlocal, NlocalCache, verbose)
}

cholBatchBackend <- function(A, D, Astartend, Dstartend, numbatchD, Nglobal, Nlocal, NlocalCache) {
    invisible(.Call('_gpuLik_cholBatchBackend', PACKAGE = 'gpuLik', A, D, Astartend, Dstartend, numbatchD, Nglobal, Nlocal, NlocalCache))
}

#' Multiply crossproduct matrices
#' 
#' Computes C = t(A) D A
crossprodBatchBackend <- function(C, A, D, invertD, Cstartend, Astartend, Dstartend, Nglobal, Nlocal, NlocalCache, verbose) {
    .Call('_gpuLik_crossprodBatchBackend', PACKAGE = 'gpuLik', C, A, D, invertD, Cstartend, Astartend, Dstartend, Nglobal, Nlocal, NlocalCache, verbose)
}

gemmBatch2backend <- function(A, B, C, transposeABC, submatrixA, submatrixB, submatrixC, batches, workgroupSize, NlocalCache, verbose) {
    .Call('_gpuLik_gemmBatch2backend', PACKAGE = 'gpuLik', A, B, C, transposeABC, submatrixA, submatrixB, submatrixC, batches, workgroupSize, NlocalCache, verbose)
}

likfitGpu_BackendP <- function(yx, coords, params, boxcox, ssqY, XVYXVX, ssqBetahat, detVar, detReml, jacobian, NparamPerIter, workgroupSize, localSize, NlocalCache, verbose, ssqYX, ssqYXcopy, LinvYX, QinvSsqYx, cholXVXdiag, varMat, cholDiagMat) {
    invisible(.Call('_gpuLik_likfitGpu_BackendP', PACKAGE = 'gpuLik', yx, coords, params, boxcox, ssqY, XVYXVX, ssqBetahat, detVar, detReml, jacobian, NparamPerIter, workgroupSize, localSize, NlocalCache, verbose, ssqYX, ssqYXcopy, LinvYX, QinvSsqYx, cholXVXdiag, varMat, cholDiagMat))
}

mat_vec_eledivideBackend <- function(matrixR, rowvectorR, resultR, numWorkItems) {
    invisible(.Call('_gpuLik_mat_vec_eledivideBackend', PACKAGE = 'gpuLik', matrixR, rowvectorR, resultR, numWorkItems))
}

matrix_vector_sumBackend <- function(matrixR, rowvectorR, colvectorR, constantR, sumR, numWorkItems) {
    invisible(.Call('_gpuLik_matrix_vector_sumBackend', PACKAGE = 'gpuLik', matrixR, rowvectorR, colvectorR, constantR, sumR, numWorkItems))
}

fillParamsExtra <- function(param) {
    invisible(.Call('_gpuLik_fillParamsExtra', PACKAGE = 'gpuLik', param))
}

maternBatchBackend <- function(var, coords, param, Nglobal, Nlocal, startrow, numberofrows, verbose = 0L) {
    invisible(.Call('_gpuLik_maternBatchBackend', PACKAGE = 'gpuLik', var, coords, param, Nglobal, Nlocal, startrow, numberofrows, verbose))
}

multiplyLowerDiagonalBatchBackend <- function(output, L, D, B, diagIsOne, transformD, Nglobal, Nlocal, NlocalCache) {
    .Call('_gpuLik_multiplyLowerDiagonalBatchBackend', PACKAGE = 'gpuLik', output, L, D, B, diagIsOne, transformD, Nglobal, Nlocal, NlocalCache)
}

multiplyDiagonalBatchBackend <- function(C, A, B, inverse, Nglobal, Nlocal) {
    .Call('_gpuLik_multiplyDiagonalBatchBackend', PACKAGE = 'gpuLik', C, A, B, inverse, Nglobal, Nlocal)
}

#' Multiply lower triangular matrices
#' 
#' Multiplies a lower triangular matrix by a rectangular matrix
#'
#' @param C output matrices, stacked row-wise
#' @param A lower triangular matrices
#' @param B rectangular matrix or matrices
#' @param Nglobal vector of number of global work items: Drow, Dcol, Dmatrix
#' @param Nlocal vector of number of local work items anything, anything, 1
#' @param NlocalCache elements in local cache
#' @export
multiplyLowerBatchBackend <- function(C, A, B, diagIsOne, Nglobal, Nlocal, NlocalCache) {
    .Call('_gpuLik_multiplyLowerBatchBackend', PACKAGE = 'gpuLik', C, A, B, diagIsOne, Nglobal, Nlocal, NlocalCache)
}

